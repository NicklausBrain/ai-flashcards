using My1kWordsEe.Models.Semantics;
using My1kWordsEe.Services.Scoped;

namespace My1kWordsEe.Models.Games.Generation
{
    public class NextWordSelector
    {
        private readonly EtWordsCache etWordsCache;
        private readonly FavoritesStateContainer favoritesStateContainer;

        public NextWordSelector(
            EtWordsCache etWordsCache,
            FavoritesStateContainer favoritesStateContainer)
        {
            this.etWordsCache = etWordsCache;
            this.favoritesStateContainer = favoritesStateContainer;
        }

        // generated by o1
        public async Task<EtWord> GetNextWord()
        {
            var favorites = await favoritesStateContainer.GetAsync();

            var words = favorites.IsSuccess ?
                        favorites.Value.Words.Values.Concat(etWordsCache.AllWords).Distinct().ToList()
                        : etWordsCache.AllWords.ToList();

            var stats = favorites.IsSuccess ? favorites.Value.Stats : new Dictionary<string, int>();

            // Assign weights: Higher known words (score 10) have the smallest weight (1), unknown words (score 0) have the highest weight (121)
            var weightedWords = new List<EtWord>();

            foreach (var word in words)
            {
                int score = stats.TryGetValue(word.Value.ToLowerInvariant(), out var s) ? s : 0;
                int weight = (11 - score) * (11 - score); // Square-based weight distribution

                for (int i = 0; i < weight; i++)
                {
                    weightedWords.Add(word);
                }
            }

            if (weightedWords.Count == 0)
            {
                return words[new Random().Next(words.Count)]; // Fallback to random selection
            }

            var random = new Random();
            return weightedWords[random.Next(weightedWords.Count)];
        }
    }
}
